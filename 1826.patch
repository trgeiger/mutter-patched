From ba1490ec9c8dd7b02cf082a3e4c7cc07ad9aa6a1 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Wed, 15 Jul 2020 17:03:27 +0800
Subject: [PATCH 1/2] clutter/frame-clock: Remember the refresh interval

Instead of recalculating it every time we need it. The performance
gain is not important; this is more because it will be needed in
multiple functions soon.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1826>
---
 clutter/clutter/clutter-frame-clock.c | 21 ++++++++++++++++-----
 1 file changed, 16 insertions(+), 5 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 9b3b10ebac..dc5a608348 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -77,6 +77,7 @@ struct _ClutterFrameClock
   GObject parent;
 
   float refresh_rate;
+  int64_t refresh_interval_us;
   ClutterFrameListener listener;
 
   GSource *source;
@@ -131,6 +132,15 @@ clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock)
   return frame_clock->refresh_rate;
 }
 
+static void
+clutter_frame_clock_set_refresh_rate (ClutterFrameClock *frame_clock,
+                                      float              refresh_rate)
+{
+  frame_clock->refresh_rate = refresh_rate;
+  frame_clock->refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / refresh_rate);
+}
+
 void
 clutter_frame_clock_add_timeline (ClutterFrameClock *frame_clock,
                                   ClutterTimeline   *timeline)
@@ -255,7 +265,10 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     }
 
   if (frame_info->refresh_rate > 1)
-    frame_clock->refresh_rate = frame_info->refresh_rate;
+    {
+      clutter_frame_clock_set_refresh_rate (frame_clock,
+                                            frame_info->refresh_rate);
+    }
 
   switch (frame_clock->state)
     {
@@ -349,7 +362,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 {
   int64_t last_presentation_time_us;
   int64_t now_us;
-  float refresh_rate;
   int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
@@ -360,8 +372,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 
   now_us = g_get_monotonic_time ();
 
-  refresh_rate = frame_clock->refresh_rate;
-  refresh_interval_us = (int64_t) (0.5 + G_USEC_PER_SEC / refresh_rate);
+  refresh_interval_us = frame_clock->refresh_interval_us;
 
   if (frame_clock->last_presentation_time_us == 0)
     {
@@ -767,7 +778,7 @@ clutter_frame_clock_new (float                            refresh_rate,
 
   init_frame_clock_source (frame_clock);
 
-  frame_clock->refresh_rate = refresh_rate;
+  clutter_frame_clock_set_refresh_rate (frame_clock, refresh_rate);
   frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
-- 
GitLab


From 0555a5bbc15dcb7dcf125a7969a42f171fe0bb72 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 15 Apr 2021 20:30:31 +0800
Subject: [PATCH 2/2] clutter/frame-clock: Apply error diffusion (dithering) to
 dispatch times

But only the dispatch times used when `last_presentation_time_us == 0`
(Nvidia + Xorg).

This ensures the average dispatch interval is always precisely equal
to the refresh interval, regardless of any jitter in the mainloop.

Fixes: https://gitlab.gnome.org/GNOME/mutter/-/issues/1751,
       https://gitlab.gnome.org/GNOME/mutter/-/issues/1758,
       https://gitlab.gnome.org/GNOME/mutter/-/issues/1870

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1826>
---
 clutter/clutter/clutter-frame-clock.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index dc5a608348..65f6229b02 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -86,6 +86,7 @@ struct _ClutterFrameClock
 
   ClutterFrameClockState state;
   int64_t last_dispatch_time_us;
+  int64_t last_dispatch_lateness_us;
   int64_t last_presentation_time_us;
 
   gboolean is_next_presentation_time_valid;
@@ -378,7 +379,8 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
     {
       *out_next_update_time_us =
         frame_clock->last_dispatch_time_us ?
-        frame_clock->last_dispatch_time_us + refresh_interval_us :
+        ((frame_clock->last_dispatch_time_us -
+          frame_clock->last_dispatch_lateness_us) + refresh_interval_us) :
         now_us;
 
       *out_next_presentation_time_us = 0;
@@ -613,9 +615,20 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
 {
   int64_t frame_count;
   ClutterFrameResult result;
+  int64_t ideal_dispatch_time_us, lateness_us;
 
   COGL_TRACE_BEGIN_SCOPED (ClutterFrameClockDispatch, "Frame Clock (dispatch)");
 
+  ideal_dispatch_time_us = (frame_clock->last_dispatch_time_us -
+                            frame_clock->last_dispatch_lateness_us) +
+                           frame_clock->refresh_interval_us;
+
+  lateness_us = time_us - ideal_dispatch_time_us;
+  if (lateness_us < 0 || lateness_us >= frame_clock->refresh_interval_us)
+    frame_clock->last_dispatch_lateness_us = 0;
+  else
+    frame_clock->last_dispatch_lateness_us = lateness_us;
+
   frame_clock->last_dispatch_time_us = time_us;
   g_source_set_ready_time (frame_clock->source, -1);
 
-- 
GitLab

